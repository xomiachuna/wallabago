// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package database

import (
	"context"
	"database/sql"
	"time"
)

const addAccessToken = `-- name: AddAccessToken :one
INSERT INTO
	identity.access_tokens (
		token_id,
		refresh_token_id,
		client_id,
		user_id,
		jwt,
		revoked,
		expires_in_seconds,
		issued_at,
		scope,
		type
	)
VALUES
	($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
RETURNING
	token_id,
	refresh_token_id,
	client_id,
	user_id,
	jwt,
	revoked,
	expires_in_seconds,
	issued_at,
	scope,
	type
`

type AddAccessTokenParams struct {
	TokenID          string
	RefreshTokenID   sql.NullString
	ClientID         string
	UserID           string
	Jwt              string
	Revoked          bool
	ExpiresInSeconds int64
	IssuedAt         time.Time
	Scope            string
	Type             string
}

type AddAccessTokenRow struct {
	TokenID          string
	RefreshTokenID   sql.NullString
	ClientID         string
	UserID           string
	Jwt              string
	Revoked          bool
	ExpiresInSeconds int64
	IssuedAt         time.Time
	Scope            string
	Type             string
}

func (q *Queries) AddAccessToken(ctx context.Context, arg AddAccessTokenParams) (*AddAccessTokenRow, error) {
	row := q.queryRow(ctx, q.addAccessTokenStmt, addAccessToken,
		arg.TokenID,
		arg.RefreshTokenID,
		arg.ClientID,
		arg.UserID,
		arg.Jwt,
		arg.Revoked,
		arg.ExpiresInSeconds,
		arg.IssuedAt,
		arg.Scope,
		arg.Type,
	)
	var i AddAccessTokenRow
	err := row.Scan(
		&i.TokenID,
		&i.RefreshTokenID,
		&i.ClientID,
		&i.UserID,
		&i.Jwt,
		&i.Revoked,
		&i.ExpiresInSeconds,
		&i.IssuedAt,
		&i.Scope,
		&i.Type,
	)
	return &i, err
}

const addClient = `-- name: AddClient :one
INSERT INTO
	identity.clients (client_id, client_secret)
VALUES
	($1, $2)
RETURNING
	client_id,
	client_secret
`

type AddClientParams struct {
	ClientID     string
	ClientSecret string
}

func (q *Queries) AddClient(ctx context.Context, arg AddClientParams) (*IdentityClient, error) {
	row := q.queryRow(ctx, q.addClientStmt, addClient, arg.ClientID, arg.ClientSecret)
	var i IdentityClient
	err := row.Scan(&i.ClientID, &i.ClientSecret)
	return &i, err
}

const addRefreshToken = `-- name: AddRefreshToken :one
INSERT INTO
	identity.refresh_tokens (token_id, client_id, jwt, revoked)
VALUES
	($1, $2, $3, $4)
RETURNING
	token_id,
	client_id,
	jwt,
	revoked
`

type AddRefreshTokenParams struct {
	TokenID  string
	ClientID string
	Jwt      string
	Revoked  bool
}

func (q *Queries) AddRefreshToken(ctx context.Context, arg AddRefreshTokenParams) (*IdentityRefreshToken, error) {
	row := q.queryRow(ctx, q.addRefreshTokenStmt, addRefreshToken,
		arg.TokenID,
		arg.ClientID,
		arg.Jwt,
		arg.Revoked,
	)
	var i IdentityRefreshToken
	err := row.Scan(
		&i.TokenID,
		&i.ClientID,
		&i.Jwt,
		&i.Revoked,
	)
	return &i, err
}

const addUser = `-- name: AddUser :one
INSERT INTO
	identity.users (user_id, username, email, password_hash)
VALUES
	($1, $2, $3, $4)
RETURNING
	user_id,
	username,
	email,
	password_hash
`

type AddUserParams struct {
	UserID       string
	Username     string
	Email        string
	PasswordHash []byte
}

func (q *Queries) AddUser(ctx context.Context, arg AddUserParams) (*IdentityUser, error) {
	row := q.queryRow(ctx, q.addUserStmt, addUser,
		arg.UserID,
		arg.Username,
		arg.Email,
		arg.PasswordHash,
	)
	var i IdentityUser
	err := row.Scan(
		&i.UserID,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
	)
	return &i, err
}

const deleteAccessTokenByID = `-- name: DeleteAccessTokenByID :exec
DELETE FROM identity.access_tokens
WHERE
	token_id = $1
`

func (q *Queries) DeleteAccessTokenByID(ctx context.Context, tokenID string) error {
	_, err := q.exec(ctx, q.deleteAccessTokenByIDStmt, deleteAccessTokenByID, tokenID)
	return err
}

const deleteClientByID = `-- name: DeleteClientByID :exec
DELETE FROM identity.clients
WHERE
	client_id = $1
`

func (q *Queries) DeleteClientByID(ctx context.Context, clientID string) error {
	_, err := q.exec(ctx, q.deleteClientByIDStmt, deleteClientByID, clientID)
	return err
}

const deleteRefreshTokenByID = `-- name: DeleteRefreshTokenByID :exec
DELETE FROM identity.refresh_tokens
WHERE
	token_id = $1
`

func (q *Queries) DeleteRefreshTokenByID(ctx context.Context, tokenID string) error {
	_, err := q.exec(ctx, q.deleteRefreshTokenByIDStmt, deleteRefreshTokenByID, tokenID)
	return err
}

const deleteUserByID = `-- name: DeleteUserByID :exec
DELETE FROM identity.users
WHERE
	user_id = $1
`

func (q *Queries) DeleteUserByID(ctx context.Context, userID string) error {
	_, err := q.exec(ctx, q.deleteUserByIDStmt, deleteUserByID, userID)
	return err
}

const getAccessTokenByJWT = `-- name: GetAccessTokenByJWT :one
SELECT
	token_id,
	refresh_token_id,
	client_id,
	user_id,
	jwt,
	revoked,
	expires_in_seconds,
	issued_at,
	scope,
	type
FROM
	identity.access_tokens
WHERE
	jwt = $1
LIMIT
	1
`

type GetAccessTokenByJWTRow struct {
	TokenID          string
	RefreshTokenID   sql.NullString
	ClientID         string
	UserID           string
	Jwt              string
	Revoked          bool
	ExpiresInSeconds int64
	IssuedAt         time.Time
	Scope            string
	Type             string
}

func (q *Queries) GetAccessTokenByJWT(ctx context.Context, jwt string) (*GetAccessTokenByJWTRow, error) {
	row := q.queryRow(ctx, q.getAccessTokenByJWTStmt, getAccessTokenByJWT, jwt)
	var i GetAccessTokenByJWTRow
	err := row.Scan(
		&i.TokenID,
		&i.RefreshTokenID,
		&i.ClientID,
		&i.UserID,
		&i.Jwt,
		&i.Revoked,
		&i.ExpiresInSeconds,
		&i.IssuedAt,
		&i.Scope,
		&i.Type,
	)
	return &i, err
}

const getClientByID = `-- name: GetClientByID :one
SELECT
	client_id,
	client_secret
FROM
	identity.clients
WHERE
	client_id = $1
LIMIT
	1
`

func (q *Queries) GetClientByID(ctx context.Context, clientID string) (*IdentityClient, error) {
	row := q.queryRow(ctx, q.getClientByIDStmt, getClientByID, clientID)
	var i IdentityClient
	err := row.Scan(&i.ClientID, &i.ClientSecret)
	return &i, err
}

const getRefreshTokenByJWT = `-- name: GetRefreshTokenByJWT :one
SELECT
	token_id,
	client_id,
	jwt,
	revoked
FROM
	identity.refresh_tokens
WHERE
	jwt = $1
LIMIT
	1
`

func (q *Queries) GetRefreshTokenByJWT(ctx context.Context, jwt string) (*IdentityRefreshToken, error) {
	row := q.queryRow(ctx, q.getRefreshTokenByJWTStmt, getRefreshTokenByJWT, jwt)
	var i IdentityRefreshToken
	err := row.Scan(
		&i.TokenID,
		&i.ClientID,
		&i.Jwt,
		&i.Revoked,
	)
	return &i, err
}

const getUserByUsername = `-- name: GetUserByUsername :one
SELECT
	user_id,
	username,
	email,
	password_hash
FROM
	identity.users
WHERE
	username = $1
LIMIT
	1
`

func (q *Queries) GetUserByUsername(ctx context.Context, username string) (*IdentityUser, error) {
	row := q.queryRow(ctx, q.getUserByUsernameStmt, getUserByUsername, username)
	var i IdentityUser
	err := row.Scan(
		&i.UserID,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
	)
	return &i, err
}

const revokeAccessTokenByID = `-- name: RevokeAccessTokenByID :one
UPDATE identity.access_tokens
SET
	revoked = TRUE
WHERE
	token_id = $1
RETURNING
	token_id,
	refresh_token_id,
	client_id,
	user_id,
	jwt,
	revoked,
	expires_in_seconds,
	issued_at,
	scope,
	type
`

type RevokeAccessTokenByIDRow struct {
	TokenID          string
	RefreshTokenID   sql.NullString
	ClientID         string
	UserID           string
	Jwt              string
	Revoked          bool
	ExpiresInSeconds int64
	IssuedAt         time.Time
	Scope            string
	Type             string
}

func (q *Queries) RevokeAccessTokenByID(ctx context.Context, tokenID string) (*RevokeAccessTokenByIDRow, error) {
	row := q.queryRow(ctx, q.revokeAccessTokenByIDStmt, revokeAccessTokenByID, tokenID)
	var i RevokeAccessTokenByIDRow
	err := row.Scan(
		&i.TokenID,
		&i.RefreshTokenID,
		&i.ClientID,
		&i.UserID,
		&i.Jwt,
		&i.Revoked,
		&i.ExpiresInSeconds,
		&i.IssuedAt,
		&i.Scope,
		&i.Type,
	)
	return &i, err
}

const revokeRefreshTokenByID = `-- name: RevokeRefreshTokenByID :one
UPDATE identity.refresh_tokens
SET
	revoked = TRUE
WHERE
	token_id = $1
RETURNING
	token_id,
	client_id,
	jwt,
	revoked
`

func (q *Queries) RevokeRefreshTokenByID(ctx context.Context, tokenID string) (*IdentityRefreshToken, error) {
	row := q.queryRow(ctx, q.revokeRefreshTokenByIDStmt, revokeRefreshTokenByID, tokenID)
	var i IdentityRefreshToken
	err := row.Scan(
		&i.TokenID,
		&i.ClientID,
		&i.Jwt,
		&i.Revoked,
	)
	return &i, err
}
